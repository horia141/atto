* [15.06.2011-xx.xx.xxxx]
  There is too much copying going around. A mechanism shoul be in place
  for coping with this. There are only so many mutable like operations
  happening. We could implement usage counters and only modify when
  strictly necessary. Also, environments should be better managed. Every
  function in existance shouldn't have a copy of the whole environment.
  Massive sharing is possible here. Maybe not in Python, though.

* [15.06.2011-xx.xx.xxxx]
  Make builtin functions "Callable" agnostic. They should work on any
  callable object, with the caveat that most operations raise an exception
  on "BuiltIn" objects.

+ [15.06.2011-15.06.2011]
  > Made the necessary modifications.

  Change "lookup","lookupWNone","update" etc. functions to "simpler
  names": "get","set" etc. Also, replace "lookup" with "lookupWName"
  and update the builtin functions to work accordingly.

+ [14.06.2011-15.06.2011]
  > Did the necessary refactoring. The code is much simpler now. I've
  > also added a "InAtom" derived class, called "Callable" which describes
  > objects which can be called (such as functions and builtins).

  The "apply" function in  "Func" is very similar in function to what
  happens when we "interpret" a call to a "Func" object. We should merge
  the two functionalities (the "interpret" routine should call "apply"
  after it has evaluated all the arguments).

* [14.06.2011-xx.xx.xxxx]
  Add proper tests for builtin functions which receive '_star' and
  '_plus' arguments.

+ [07.06.2011-07.06.2011]
  > Added this, by way of "Finished support for new argument format for
  > functions." commit.

  Change argument order so that all order arguments are first, followed
  by all named arguments.

+ [02.06.2011-07.06.2011]
  > I won't add these, for the moment. We need to get some more working
  > code. When I'm going to be hurting for it, I'll add it. Otherwise,
  > there's some gratuitous complexity we can't really afford now.

  Add filters to arguments. These should be one argument functions,
  which we associate with a specific argument and which return either
  "#T" or "#F". When the function is invoked, each parameter has the
  specific filter executed and we raise an exception if an "#F" is
  obtained. This is flexible type-checking. As an example, consider:

    que := [x@(is-number) y@(is-array)=1|2 (...)]

  This would produce:

    (que 10 1|2|3) => ...
    (que Hello 1|2|3) => Exception ...

+ [02.06.2011-07.06.2011]
  > Added this, by way of "Finished support for new argument format for
  > functions." commit. The meaning is not quite the same, but expanded
  > instead, to encompass a more general view of the types of arguments
  > allowed.

  Add optional arguments. These should have a mandatory default value.
  They can't be filled by order/positional arguments when calling, but
  must be explicitly specified by the caller as a named argument. For
  example:

    que := [x y z=10? (+ (x) (y) (z))

  Would produce:

    (que 10 20) => 40
    (que 10 20 30) => Exception ...
    (que 10 20 z=30) => 60

  This will help mightily for complex functions with variable arguments.

+ [01.06.2011-02.06.2011]
  > No can do this. If the object is a dictionary, it might depend in
  > the building of one of its keys or values on a parameter. These are
  > known only at invocation time, not when the function is created. This
  > could work for booleans, numbers, symbols and strings (not ones defined
  > through "StringEval" though), but these are simple to evaluate anyhow.

  In "Interpreter.interpret", if we evaluate a function and the type of
  its body is not "Parser.Call" - that is, it is an data type, we evaluate
  the object as well. We'll need to upgrade the definition of an "Func",
  but we'll get a nice speed bonus for constructors and the like.

+ [30.05.2011-02.06.2011] 
  > Fixed by new types and new syntax. We have symbols, which are the only
  > things than can identify an object in the environment. These can only
  > contain alphanumerics and some special characters. Therefore we won't
  > have problems with embedded special characters.

  Fix syntax issues with '=',':','+','*'. We should treat '+' and '*' as
  normal symbols and let them be part of other symbols. If in the argument
  list of a function, we find at the end of the last argument either '+' or
  '*' we interpret it as a vararg. We won't treat '+' and '*' as separate
  lexemes though. '=' and ':' won't be treated as symbols anymore though and
  they will have to have just a fixed meaning.

+ [30.05.2011-07.06.2011]
  > Added this, by way of "Finished support for new argument format for
  > functions." commit. The meaning is not quite the same, but expanded
  > instead, to encompass a more general view of the types of arguments
  > allowed.

  Add default arguments for functions. The form should be:

    que := [x y=20 (+ :x :y)]

  This would produce

    (que 10 30) => 40
    (que 10) => 30
    (que y=30) => Exception ...

* [30.05.2011-xx.xx.xxxx]
  Make auto-argument parsing when executing a script. We define a boot
  function and, depending on its arguments, generate appropriate getopt
  calls.

   que := [x y=30 debug (...)]

  Then, assuming we have to invoke "atto" as the interpreter command,
  we'd get:

   ./atto -boot=que -x 30 -y 100
