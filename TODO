* [07.06.2011-xx.xx.xxxx]
  Change argument order so that all order arguments are first, followed
  by all named arguments.

* [02.06.2011-xx.xx.xxxx]
  Add filters to arguments. These should be one argument functions,
  which we associate with a specific argument and which return either
  "#T" or "#F". When the function is invoked, each parameter has the
  specific filter executed and we raise an exception if an "#F" is
  obtained. This is flexible type-checking. As an example, consider:

    que := [x@(is-number) y@(is-array)=1|2 (...)]

  This would produce:

    (que 10 1|2|3) => ...
    (que Hello 1|2|3) => Exception ...

* [02.06.2011-xx.xx.xxxx]
  Add optional arguments. These should have a mandatory default value.
  They can't be filled by order/positional arguments when calling, but
  must be explicitly specified by the caller as a named argument. For
  example:

    que := [x y z=10? (+ (x) (y) (z))

  Would produce:

    (que 10 20) => 40
    (que 10 20 30) => Exception ...
    (que 10 20 z=30) => 60

  This will help mightily for complex functions with variable arguments.

+ [01.06.2011-02.06.2011]
  > No can do this. If the object is a dictionary, it might depend in
  > the building of one of its keys or values on a parameter. These are
  > known only at invocation time, not when the function is created. This
  > could work for booleans, numbers, symbols and strings (not ones defined
  > through "StringEval" though), but these are simple to evaluate anyhow.

  In "Interpreter.interpret", if we evaluate a function and the type of
  its body is not "Parser.Call" - that is, it is an data type, we evaluate
  the object as well. We'll need to upgrade the definition of an "Func",
  but we'll get a nice speed bonus for constructors and the like.

+ [30.05.2011-02.06.2011] 
  > Fixed by new types and new syntax. We have symbols, which are the only
  > things than can identify an object in the environment. These can only
  > contain alphanumerics and some special characters. Therefore we won't
  > have problems with embedded special characters.

  Fix syntax issues with '=',':','+','*'. We should treat '+' and '*' as
  normal symbols and let them be part of other symbols. If in the argument
  list of a function, we find at the end of the last argument either '+' or
  '*' we interpret it as a vararg. We won't treat '+' and '*' as separate
  lexemes though. '=' and ':' won't be treated as symbols anymore though and
  they will have to have just a fixed meaning.

* [30.05.2011-xx.xx.xxxx]
  Add default arguments for functions. The form should be:

    que := [x y=20 (+ :x :y)]

  This would produce

    (que 10 30) => 40
    (que 10) => 30
    (que y=30) => Exception ...

* [30.05.2011-xx.xx.xxxx]
  Make auto-argument parsing when executing a script. We define a boot
  function and, depending on its arguments, generate appropriate getopt
  calls.

   que := [x y=30 debug (...)]

  Then, assuming we have to invoke "atto" as the interpreter command,
  we'd get:

   ./atto -boot=que -x 30 -y 100
